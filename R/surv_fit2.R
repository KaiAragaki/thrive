#' @include utilities.R surv_group_by.R
NULL
#' Create Survival Curves
#'
#' @description Wrapper around the standard \link[survival]{survfit}() function to create
#'   survival curves.
#'
#' @param formula survival formula. See \link[survival]{survfit.formula}. Can be a list of formula. Named lists are recommended.
#' @param data a data frame in which to interpret the variables named in the formula.
#' Can be a list of data sets. Named lists are recommended.
#' Can be also a grouped dataset as generated by the function \link{surv_group_by}().
#' @param group.by a grouping variables to group the data set by.
#' A character vector containing the name of grouping variables. Should be of length <= 2.
#' @param match.fd logical value. Default is FALSE. Stands for "match formula and data".
#' Useful only when you have a list of formulas and a list of data sets, and
#'   you want to apply each formula to the matching data set with the same index/position in the list.
#'   For example formula1 is applied to data 1, formula2 is applied to data 2, and so on ....
#'   In this case use match.fd = TRUE.
#' @param ... Other arguments passed to the \link[survival]{survfit.formula} function.
#'
#' @return
#' \itemize{
#' \item Returns an object of class survfit if one formula and one data set provided.
#' \item Returns a named list of survfit objects when input is a list of formulas and/or data sets.
#' The same holds true when grouped data sets are provided or when the argument \code{group.by} is specified.
#' \itemize{
#' \item If the names of formula and data lists are available,
#' the names of the resulting survfit objects list are obtained by collapsing the names of formula and data lists.
#' \item If the formula names are not available, the variables in the formulas are extracted and used to build the name of survfit object.
#' \item In the case of grouped data sets, the names of survfit object list are obtained by
#' collapsing the levels of grouping variables and the names of variables in the survival curve formulas.
#' }
#' }
#' @rdname surv_fit
#' @export
surv_fit <- new_generic("surv_fit", c("formula", "data"))

method(surv_fit, list(new_class("formula"), class_data.frame)) <-
  function(formula, data, group.by = NULL, ...) {

    if (!is.null(group.by)) {
      data <- surv_group_by(data, group.by)
      return(surv_fit(formula, data$data, ...))
    }

    survfit(formula, data, ...)
  }

method(surv_fit, list(class_list, class_data.frame)) <-
  function(formula, data, group.by = NULL, match.fd, ...) {

    if (!is.null(group.by)) {
      data <- surv_group_by(data, group.by)
      return(surv_fit(formula, data$data, match.fd = match.fd, ...))
    }

    mapply(survfit, formula = formula, data = data, ..., USE.NAMES = FALSE, SIMPLIFY = FALSE)
  }

method(surv_fit, list(new_class("formula"), class_list)) <-
  function(formula, data, ...) {
    mapply(survfit, formula = list(formula), data = data, USE.NAMES = FALSE, SIMPLIFY = FALSE)
  }

method(surv_fit, list(class_list, class_list)) <- function(formula, data, match.fd, ...) {
  if (match.fd) {
    return(mapply(survfit, formula = Surv, data = data, ..., USE.NAMES = FALSE, SIMPLIFY = FALSE))
  }

  eg <- expand.grid(formula = formula, data = data)
  mapply(survfit, formula = eg$formula, data = eg$data, ..., USE.NAMES = FALSE, SIMPLIFY = FALSE)
}
surv_fit <- function(formula, data, group.by = NULL, match.fd = FALSE, ...){

  # List of formulas and List of data sets with match.fd = TRUE
  #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  # They should have the same length.
  # Each formula is applied to each data set of the same index
  if(.is_list (formula) & .is_list (data) & match.fd){

    if(length(formula) != length(data))
      stop("When formula and data are lists, ",
           "they should have the same length")

    res <- purrr::map2(formula, data, .survfit1,  ...)

  }

  # List of formulas and List of data sets with match.fd = FALSE
  #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  # Map each formula to each of the  data in the data lists ==> returns a list of survfit objects for each formula
  # Combine all lists to one single list
  else if(.is_list (formula) & .is_list (data) & !match.fd){

    .map_each <- function(formula, data){
      purrr::map(data, .survfit2, formula, ...)
    }
    res <- purrr::map(formula, .map_each , data) %>%
      dplyr::combine()
  }

  # List of formulas and One data set
  #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  # Differents formula are applied to the same data set
  else if(.is_list (formula) & !.is_list (data)){
    res <- purrr::map(formula, .survfit1, data, ...)
  }

  # Name of survfit objects list
  #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  # Names are obtained by collapsing data and formula names

  # Data names
  #..............................................
  # If users provide a named list (ex: list(colon = colon, lung = lung)), things are easy: DNAME <- names(data.list)
  # But, if user provide list(colon, lung), then we need to extract DNAME by using deparse() and substitute
  if(.is_list(data)){
    DNAME <- names(data)
    if(is.null(DNAME) & !.is_grouped_data(input_data)){
      DNAME <-  deparse(substitute(data)) %>%
        as.character() %>% gsub("list\\(|\\)", "", .) %>%
        strsplit(., ",\\s*", perl = TRUE) %>% unlist()
    }
  }
  else DNAME <- deparse(substitute(data))

  # Formula names
  #..............................................
  FNAME <- .get_formula_names(formula)

  if(.is_list (formula) & .is_list (data) & !match.fd){
    # We need to 1) repeat each formula name as many times as the length of data list
    # 2) repeat all data names as many times as the lentgh of formulas list ===>
    # All the possible combinations ordered by formula: d1::f1, d2::f1, d3::f1; d1::f2, d2::f2, ...
    nf <- length(formula)
    ndata <- length(data)
    FNAME <- rep(FNAME, each = ndata )
    DNAME <- rep(DNAME, nf)
  }


  if(.is_list(data) | .is_list(formula))
    names(res) <- .collapse(DNAME, FNAME, sep = "::")

  res
}
